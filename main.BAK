#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <time.h>
#include "thpool.h"

#define MAX_PIXEL_VALUE 255
#define KERNEL_SIZE 3
#define HISTOGRAM_SIZE 256

typedef unsigned char pixel_t;

int num_threads = 4;
threadpool thpool;

// Structure to hold image data
typedef struct {
    pixel_t* data;
    int width;
    int height;
} Image;

// Thread task structures
typedef struct {
    Image* input;
    Image* output;
    int start_row;
    int end_row;
} RowTask;

typedef struct {
    Image* input;
    Image* output;
    int start_idx;
    int end_idx;
    pixel_t* lookup;
} HistogramTask;

// Function to create new image
Image* create_image(int width, int height) {
    Image* img = (Image*)malloc(sizeof(Image));
    img->width = width;
    img->height = height;
    img->data = (pixel_t*)calloc(width * height, sizeof(pixel_t));
    return img;
}

// Function to free image
void free_image(Image* img) {
    free(img->data);
    free(img);
}

// Function to get pixel value
pixel_t get_pixel(Image* img, int x, int y) {
    if (x < 0 || x >= img->width || y < 0 || y >= img->height) {
        return 0;
    }
    return img->data[y * img->width + x];
}

// Function to set pixel value
void set_pixel(Image* img, int x, int y, pixel_t value) {
    if (x < 0 || x >= img->width || y < 0 || y >= img->height) {
        return;
    }
    img->data[y * img->width + x] = value;
}

// Sobel edge detection worker function
void sobel_worker(void* arg) {
    RowTask* task = (RowTask*)arg;

    // Sobel kernels
    const int sobel_x[3][3] = {
        {-1, 0, 1},
        {-2, 0, 2},
        {-1, 0, 1}
    };
    const int sobel_y[3][3] = {
        {-1, -2, -1},
        {0, 0, 0},
        {1, 2, 1}
    };

    for (int y = task->start_row; y < task->end_row; y++) {
        for (int x = 1; x < task->input->width - 1; x++) {
            int gx = 0, gy = 0;

            // Apply kernels
            for (int ky = -1; ky <= 1; ky++) {
                for (int kx = -1; kx <= 1; kx++) {
                    pixel_t pixel = get_pixel(task->input, x + kx, y + ky);
                    gx += pixel * sobel_x[ky + 1][kx + 1];
                    gy += pixel * sobel_y[ky + 1][kx + 1];
                }
            }

            // Calculate magnitude
            int magnitude = (int)sqrt(gx * gx + gy * gy);
            magnitude = magnitude > MAX_PIXEL_VALUE ? MAX_PIXEL_VALUE : magnitude;
            set_pixel(task->output, x, y, (pixel_t)magnitude);
        }
    }

    free(task);
}

// Sobel edge detection
Image* sobel_edge_detection(Image* input) {
    Image* output = create_image(input->width, input->height);

    int rows_per_thread = (input->height - 2) / num_threads;

    for (int i = 0; i < num_threads; i++) {
        RowTask* task = (RowTask*)malloc(sizeof(RowTask));
        task->input = input;
        task->output = output;
        task->start_row = 1 + i * rows_per_thread;
        task->end_row = (i == num_threads - 1) ? input->height - 1 : 1 + (i + 1) * rows_per_thread;

        thpool_add_work(thpool, sobel_worker, task);
    }

    thpool_wait(thpool);

    return output;
}

// Gaussian blur worker function
void gaussian_worker(void* arg) {
    RowTask* task = (RowTask*)arg;

    // Gaussian kernel (3x3)
    const float kernel[3][3] = {
        {1.0/16, 2.0/16, 1.0/16},
        {2.0/16, 4.0/16, 2.0/16},
        {1.0/16, 2.0/16, 1.0/16}
    };

    for (int y = task->start_row; y < task->end_row; y++) {
        for (int x = 1; x < task->input->width - 1; x++) {
            float sum = 0.0;

            // Apply kernel
            for (int ky = -1; ky <= 1; ky++) {
                for (int kx = -1; kx <= 1; kx++) {
                    pixel_t pixel = get_pixel(task->input, x + kx, y + ky);
                    sum += pixel * kernel[ky + 1][kx + 1];
                }
            }

            set_pixel(task->output, x, y, (pixel_t)sum);
        }
    }

    free(task);
}

// Gaussian blur
Image* gaussian_blur(Image* input) {
    Image* output = create_image(input->width, input->height);

    int rows_per_thread = (input->height - 2) / num_threads;

    for (int i = 0; i < num_threads; i++) {
        RowTask* task = (RowTask*)malloc(sizeof(RowTask));
        task->input = input;
        task->output = output;
        task->start_row = 1 + i * rows_per_thread;
        task->end_row = (i == num_threads - 1) ? input->height - 1 : 1 + (i + 1) * rows_per_thread;

        thpool_add_work(thpool, gaussian_worker, task);
    }

    thpool_wait(thpool);

    return output;
}

// Histogram equalization worker function
void histogram_worker(void* arg) {
    HistogramTask* task = (HistogramTask*)arg;

    for (int i = task->start_idx; i < task->end_idx; i++) {
        task->output->data[i] = task->lookup[task->input->data[i]];
    }

    free(task);
}

// Histogram equalization
Image* histogram_equalization(Image* input) {
    int histogram[HISTOGRAM_SIZE] = {0};
    float cdf[HISTOGRAM_SIZE] = {0.0};
    int pixel_count = input->width * input->height;
    Image* output = create_image(input->width, input->height);

    // Calculate histogram
    for (int i = 0; i < pixel_count; i++) {
        histogram[input->data[i]]++;
    }

    // Calculate cumulative distribution function
    cdf[0] = histogram[0];
    for (int i = 1; i < HISTOGRAM_SIZE; i++) {
        cdf[i] = cdf[i-1] + histogram[i];
    }

    // Normalize CDF
    for (int i = 0; i < HISTOGRAM_SIZE; i++) {
        cdf[i] /= pixel_count;
    }

    // Apply equalization using lookup table (parallelizable)
    pixel_t* lookup = (pixel_t*)malloc(HISTOGRAM_SIZE * sizeof(pixel_t));
    for (int i = 0; i < HISTOGRAM_SIZE; i++) {
        lookup[i] = (pixel_t)(cdf[i] * MAX_PIXEL_VALUE);
    }

    int pixels_per_thread = pixel_count / num_threads;

    for (int i = 0; i < num_threads; i++) {
        HistogramTask* task = (HistogramTask*)malloc(sizeof(HistogramTask));
        task->input = input;
        task->output = output;
        task->lookup = lookup;
        task->start_idx = i * pixels_per_thread;
        task->end_idx = (i == num_threads - 1) ? pixel_count : (i + 1) * pixels_per_thread;

        thpool_add_work(thpool, histogram_worker, task);
    }

    thpool_wait(thpool);

    free(lookup);

    return output;
}

// Dilation worker function
void dilate_worker(void* arg) {
    RowTask* task = (RowTask*)arg;

    for (int y = task->start_row; y < task->end_row; y++) {
        for (int x = 1; x < task->input->width - 1; x++) {
            pixel_t max_value = 0;

            // Find maximum in 3x3 neighborhood
            for (int ky = -1; ky <= 1; ky++) {
                for (int kx = -1; kx <= 1; kx++) {
                    pixel_t pixel = get_pixel(task->input, x + kx, y + ky);
                    if (pixel > max_value) {
                        max_value = pixel;
                    }
                }
            }

            set_pixel(task->output, x, y, max_value);
        }
    }

    free(task);
}

// Morphological dilation
Image* dilate(Image* input) {
    Image* output = create_image(input->width, input->height);

    int rows_per_thread = (input->height - 2) / num_threads;

    for (int i = 0; i < num_threads; i++) {
        RowTask* task = (RowTask*)malloc(sizeof(RowTask));
        task->input = input;
        task->output = output;
        task->start_row = 1 + i * rows_per_thread;
        task->end_row = (i == num_threads - 1) ? input->height - 1 : 1 + (i + 1) * rows_per_thread;

        thpool_add_work(thpool, dilate_worker, task);
    }

    thpool_wait(thpool);

    return output;
}

// Erosion worker function
void erode_worker(void* arg) {
    RowTask* task = (RowTask*)arg;

    for (int y = task->start_row; y < task->end_row; y++) {
        for (int x = 1; x < task->input->width - 1; x++) {
            pixel_t min_value = MAX_PIXEL_VALUE;

            // Find minimum in 3x3 neighborhood
            for (int ky = -1; ky <= 1; ky++) {
                for (int kx = -1; kx <= 1; kx++) {
                    pixel_t pixel = get_pixel(task->input, x + kx, y + ky);
                    if (pixel < min_value) {
                        min_value = pixel;
                    }
                }
            }

            set_pixel(task->output, x, y, min_value);
        }
    }

    free(task);
}

// Morphological erosion
Image* erode(Image* input) {
    Image* output = create_image(input->width, input->height);

    int rows_per_thread = (input->height - 2) / num_threads;

    for (int i = 0; i < num_threads; i++) {
        RowTask* task = (RowTask*)malloc(sizeof(RowTask));
        task->input = input;
        task->output = output;
        task->start_row = 1 + i * rows_per_thread;
        task->end_row = (i == num_threads - 1) ? input->height - 1 : 1 + (i + 1) * rows_per_thread;

        thpool_add_work(thpool, erode_worker, task);
    }

    thpool_wait(thpool);

    return output;
}

// Function to apply all transformations in sequence
Image* process_image(Image* input) {
    Image* temp1, *temp2, *temp3, *temp4, *result;

    // Apply gaussian blur first to reduce noise
    temp1 = gaussian_blur(input);

    // Apply edge detection
    temp2 = sobel_edge_detection(temp1);

    // Enhance edges through histogram equalization
    temp3 = histogram_equalization(temp2);

    // Apply morphological operations to clean up edges
    temp4 = dilate(temp3);
    result = erode(temp4);

    // Clean up intermediate results
    free_image(temp1);
    free_image(temp2);
    free_image(temp3);
    free_image(temp4);

    return result;
}

int main(int argc, char * argv[]) {

    if(argc < 3){
      printf("Usage: %s <size> <num threads>\n", argv[0]);
      return 1;
    }

    int size = atoi(argv[1]);
    int IMG_WIDTH = size;
    int IMG_HEIGHT = size;

    num_threads = atoi(argv[argc-1]);

    // Initialize threadpool
    thpool = thpool_init(num_threads);

    // Create test image with random noise
    Image* input = create_image(IMG_WIDTH, IMG_HEIGHT);
    for (int i = 0; i < IMG_WIDTH * IMG_HEIGHT; i++) {
        input->data[i] = rand() % (MAX_PIXEL_VALUE + 1);
    }

    // Process image and measure time
    clock_t start = clock();
    Image* output = process_image(input);
    clock_t end = clock();

    double cpu_time = ((double) (end - start)) / CLOCKS_PER_SEC;
    printf("Processing time: %f seconds\n", cpu_time);

    // Clean up
    free_image(input);
    free_image(output);
    thpool_destroy(thpool);

    return 0;
}
